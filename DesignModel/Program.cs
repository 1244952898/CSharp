using DesignModel.ClainOfResponsibility_责任链模式_;
using System;
using System.Collections.Concurrent;

namespace DesignModel
{
    internal class Program
    {

        /*
         单一职责：就一个类而言，应该仅有一个引起它变化点原因


        2.策略模式：定义了算法家族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化，不会影响到使用算法的客户。

        3.装饰器模式：动态的给一个对象添加额外的职责，装饰器模式比子类更加灵活

        4.代理模式：为其他对象提供一种代理以控制对这个对象的访问

        5.原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原形创建新的对象

        6.模板方法：定义操作中一个算法的骨架，将一些步骤延迟到子类中，模板方法使得子类不改变一个算法得结构即可重新定义某些方法的特定步骤

        7.外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口这个接口使子系统更加容易使用。

        8.0 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
        8.1 建造者模式：使用多个简单的对象一步一步构建成一个复杂的对象。

        9.观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个对象。此主题对象发生变化时会通知所有观察者对象，使他们自动更新自己

        10.状态模式：一个对象的内在状态改变时允许改变其行为，这个对象看起来是改变了其类
        10.1 状态模式：类的行为是基于它的状态改变的

        11.适配器模式：将一个接口转换为客户希望的另一个接口使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

        12.备忘录模式：在不破坏封装的前提下捕获一个对象内部状态，并在对象内部之外进行保存，这样以后可将该对象恢复到原先保存的状态。

        13.组合模式：将对象组合成树形结构
         */

        static void Main(string[] args)
        {
            //Console.WriteLine("Hello World!");
            //ClainOfResponsibilityDemo.main();
            //Console.ReadLine();

            //ConcurrentDictionary<int,string> keyValuePairs= new ConcurrentDictionary<int,string>();
        }
    }
}
